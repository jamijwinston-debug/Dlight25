import asyncio
import logging
import os
import aiohttp
from telegram import Update
from telegram.ext import Application, CommandHandler, MessageHandler, filters, ContextTypes
from telethon.sync import TelegramClient
from telethon.sessions import StringSession
from telethon.tl.types import UserStatusOnline, UserStatusOffline, UserStatusRecently, UserStatusLastWeek, UserStatusLastMonth

# --- CONFIGURATION ---
# Load sensitive credentials from environment variables for security.
# Get these from my.telegram.org
API_ID = os.getenv('17752898')
API_HASH = os.getenv('899d5b7bb6c1a3672d822256bffac2a3')

# Get this from BotFather on Telegram
BOT_TOKEN = os.getenv('8377696674:AAEoN1aHOBf6NoKL3LizDyLdW6mgVcTPRCY')

# This will be generated by generate_session.py and set on Render
TELETHON_SESSION = os.getenv('TELETHON_SESSION')

# (Optional) For industry analysis feature
GEMINI_API_KEY = os.getenv('GEMINI_API_KEY')
# --- END CONFIGURATION ---

# Enable logging
logging.basicConfig(
    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s',
    level=logging.INFO
)
logger = logging.getLogger(__name__)

# Initialize the Telethon client
# Use the session string if available (for deployment on Render), 
# otherwise use a local file (for local testing).
if TELETHON_SESSION:
    client = TelegramClient(StringSession(TELETHON_SESSION), API_ID, API_HASH)
else:
    client = TelegramClient('bot_session', API_ID, API_HASH)


async def get_industry_from_gemini(title: str, description: str) -> str:
    """Uses the Gemini API to determine the industry of a channel."""
    if not GEMINI_API_KEY:
        logger.warning("GEMINI_API_KEY is not set. Skipping industry analysis.")
        return "Not Analyzed"

    if not description:
        description = "No description provided."
    
    # Keep the prompt and description concise to fit within model limits
    description_snippet = (description[:4000] + '...') if len(description) > 4000 else description

    prompt = (
        "Analyze the following Telegram channel title and description to determine its primary industry or category. "
        "Provide only the category name (e.g., 'Technology', 'Cryptocurrency', 'Gaming', 'News & Media', 'Finance').\n\n"
        f"Title: {title}\n"
        f"Description: {description_snippet}"
    )

    api_url = f"https://generativelanguage.googleapis.com/v1beta/models/gemini-1.5-flash-latest:generateContent?key={GEMINI_API_KEY}"
    payload = {"contents": [{"parts": [{"text": prompt}]}]}
    headers = {'Content-Type': 'application/json'}

    try:
        async with aiohttp.ClientSession() as session:
            async with session.post(api_url, json=payload, headers=headers) as response:
                if response.status == 200:
                    data = await response.json()
                    text = data.get("candidates", [{}])[0].get("content", {}).get("parts", [{}])[0].get("text", "Could not determine")
                    return text.strip()
                else:
                    error_text = await response.text()
                    logger.error(f"Gemini API Error: {response.status} - {error_text}")
                    return "Analysis Failed"
    except Exception as e:
        logger.error(f"Error calling Gemini API: {e}")
        return "Analysis Failed"


async def start(update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:
    """Sends a welcome message when the /start command is issued."""
    welcome_text = (
        "👋 Welcome to **Dlight**!\n\n"
        "I can help you estimate the number of real vs. inactive members in a public group or channel and identify its industry.\n\n"
        "➡️ **How to use:**\n"
        "Just send me the link to a public Telegram group or channel (e.g., `https://t.me/durov` or `@durov`).\n\n"
        "⚠️ **Disclaimer:**\n"
        "The results are an estimation based on user activity (last seen status) and may not be 100% accurate. "
        "Scanning large groups can take some time.\n\n"
        "*Created by Micheal A.*"
    )
    await update.message.reply_html(welcome_text)

async def scan_link(update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:
    """Handles incoming links to scan."""
    link = update.message.text
    if "t.me/" not in link and not link.startswith('@'):
        await update.message.reply_text("Please provide a valid Telegram link (e.g., https://t.me/somegroup) or a username (e.g., @somegroup).")
        return

    # Let the user know the process has started
    status_message = await update.message.reply_text("🔍 Starting scan... This might take a few minutes for large channels. Please wait.")

    try:
        # Use the running client to get the entity (channel/group)
        entity = await client.get_entity(link)
        total_participants = entity.participants_count

        # Get industry from Gemini AI
        industry = await get_industry_from_gemini(entity.title, getattr(entity, 'about', ''))

        await status_message.edit_text("⚙️ Analyzing members... This is the longest step.")

        real_users = 0
        bots = 0
        inactive_users = 0
        
        # Use an async for loop to iterate over participants
        async for user in client.iter_participants(entity):
            if user.bot:
                bots += 1
            # Check for activity status. "Long time ago" is a strong indicator of an inactive/bought account.
            # Other statuses like offline but with a recent date are considered "real".
            elif isinstance(user.status, (UserStatusOnline, UserStatusRecently, UserStatusLastWeek, UserStatusLastMonth)) or \
               (isinstance(user.status, UserStatusOffline) and hasattr(user.status, 'was_online') and user.status.was_online.timestamp() > (asyncio.get_event_loop().time() - 30*24*60*60)): # active within 30 days
                real_users += 1
            else:
                # Anyone else is considered inactive (e.g., last seen a long time ago)
                inactive_users += 1
        
        # Calculate percentages
        real_percentage = (real_users / total_participants) * 100 if total_participants > 0 else 0
        inactive_percentage = (inactive_users / total_participants) * 100 if total_participants > 0 else 0
        bot_percentage = (bots / total_participants) * 100 if total_participants > 0 else 0

        # Create the result message
        result_text = (
            f"📊 **Scan Report for:** {entity.title}\n"
            f"💡 **Industry/Category:** {industry}\n\n"
            f"👥 **Total Members:** {total_participants}\n\n"
            f"✅ **Active Members:** {real_users} ({real_percentage:.2f}%)\n"
            f"⚪ **Inactive Members:** {inactive_users} ({inactive_percentage:.2f}%)\n"
            f"🤖 **Bots:** {bots} ({bot_percentage:.2f}%)\n\n"
            f"**Note:** 'Active' means seen within the last month. 'Inactive' means last seen a long time ago. This is an estimation."
        )
        
        await status_message.edit_text(result_text, parse_mode='HTML')

    except Exception as e:
        logger.error(f"An error occurred: {e}")
        await status_message.edit_text(f"❌ An error occurred.\nCould not scan the provided link. Please ensure it's a valid public group or channel.\n\nError: `{e}`")


async def main() -> None:
    """Start the bot and the Telethon client."""
    # --- Credentials Check ---
    if not all([API_ID, API_HASH, BOT_TOKEN]):
        logger.error("FATAL: Missing environment variables (API_ID, API_HASH, BOT_TOKEN). Please check your configuration in the README file.")
        return
    # --- End Credentials Check ---

    # Start the Telethon client first
    logger.info("Connecting Telethon client...")
    await client.start()
    logger.info("Telethon client connected.")

    # Create the Application and pass it your bot's token.
    application = Application.builder().token(BOT_TOKEN).build()

    # on different commands - answer in Telegram
    application.add_handler(CommandHandler("start", start))

    # on non command i.e message - scan the link from the message
    application.add_handler(MessageHandler(filters.TEXT & ~filters.COMMAND, scan_link))

    # Run the bot until the user presses Ctrl-C
    logger.info("Starting Telegram bot polling...")
    await application.run_polling()

    # Disconnect the client when the bot is stopped
    await client.disconnect()
    logger.info("Telethon client disconnected.")


if __name__ == '__main__':
    # The script needs to be run in an async context
    loop = asyncio.get_event_loop()
    try:
        loop.run_until_complete(main())
    except KeyboardInterrupt:
        logger.info("Bot stopped by user.")
    finally:
        if loop.is_running():
            tasks = asyncio.all_tasks(loop=loop)
            for task in tasks:
                task.cancel()
            group = asyncio.gather(*tasks, return_exceptions=True)
            loop.run_until_complete(group)
        loop.close()

